import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
export var getExtremumX = function getExtremumX(params) {
  var _axis$data, _axis$data2;
  var axis = params.axis;
  var minX = Math.min.apply(Math, _toConsumableArray((_axis$data = axis.data) != null ? _axis$data : []));
  var maxX = Math.max.apply(Math, _toConsumableArray((_axis$data2 = axis.data) != null ? _axis$data2 : []));
  return [minX, maxX];
};
export var getExtremumY = function getExtremumY(params) {
  var series = params.series,
    axis = params.axis,
    isDefaultAxis = params.isDefaultAxis;
  return Object.keys(series).filter(function (seriesId) {
    return series[seriesId].yAxisKey === axis.id || isDefaultAxis && series[seriesId].yAxisKey === undefined;
  }).reduce(function (acc, seriesId) {
    var isArea = series[seriesId].area !== undefined;
    var getValues = isArea ? function (d) {
      return d;
    } : function (d) {
      return [d[1], d[1]];
    }; // Id area should go from bottom to top, without area should only consider the top

    var _series$seriesId$stac = series[seriesId].stackedData.reduce(function (seriesAcc, stackedValue) {
        var _getValues = getValues(stackedValue),
          _getValues2 = _slicedToArray(_getValues, 2),
          base = _getValues2[0],
          value = _getValues2[1];
        return [Math.min(base, value, seriesAcc[0]), Math.max(base, value, seriesAcc[1])];
      }, getValues(series[seriesId].stackedData[0])),
      _series$seriesId$stac2 = _slicedToArray(_series$seriesId$stac, 2),
      seriesMin = _series$seriesId$stac2[0],
      seriesMax = _series$seriesId$stac2[1];
    if (acc[0] === null || acc[1] === null) {
      return [seriesMin, seriesMax];
    }
    return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];
  }, [null, null]);
};