"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scatter = Scatter;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _useScale = require("../hooks/useScale");
var _useInteractionItemProps = require("../hooks/useInteractionItemProps");
var _InteractionProvider = require("../context/InteractionProvider");
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function Scatter(props) {
  const {
    series,
    xScale,
    yScale,
    color,
    markerSize
  } = props;
  const {
    item
  } = React.useContext(_InteractionProvider.InteractionContext);
  const getInteractionItemProps = (0, _useInteractionItemProps.useInteractionItemProps)(series.highlightScope);
  const cleanData = React.useMemo(() => {
    const getXPosition = (0, _useScale.getValueToPositionMapper)(xScale);
    const getYPosition = (0, _useScale.getValueToPositionMapper)(yScale);
    const xRange = xScale.range();
    const yRange = yScale.range();
    const minXRange = Math.min(...xRange);
    const maxXRange = Math.max(...xRange);
    const minYRange = Math.min(...yRange);
    const maxYRange = Math.max(...yRange);
    const temp = [];
    for (let i = 0; i < series.data.length; i += 1) {
      const scatterPoint = series.data[i];
      const x = getXPosition(scatterPoint.x);
      const y = getYPosition(scatterPoint.y);
      const isInRange = x >= minXRange && x <= maxXRange && y >= minYRange && y <= maxYRange;
      const pointCtx = {
        type: 'scatter',
        seriesId: series.id,
        dataIndex: i
      };
      if (isInRange) {
        temp.push({
          x,
          y,
          isFaded: !(0, _useInteractionItemProps.getIsHighlighted)(item, pointCtx, series.highlightScope) && (0, _useInteractionItemProps.getIsFaded)(item, pointCtx, series.highlightScope),
          interactionProps: getInteractionItemProps(pointCtx),
          id: scatterPoint.id
        });
      }
    }
    return temp;
  }, [yScale, xScale, getInteractionItemProps, item, series.data, series.highlightScope, series.id]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)("g", {
    children: cleanData.map(dataPoint => /*#__PURE__*/(0, _jsxRuntime.jsx)("circle", (0, _extends2.default)({
      cx: 0,
      cy: 0,
      r: markerSize,
      transform: `translate(${dataPoint.x}, ${dataPoint.y})`,
      fill: color,
      opacity: dataPoint.isFaded && 0.3 || 1
    }, dataPoint.interactionProps), dataPoint.id))
  });
}
process.env.NODE_ENV !== "production" ? Scatter.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  color: _propTypes.default.string.isRequired,
  markerSize: _propTypes.default.number.isRequired,
  series: _propTypes.default.shape({
    color: _propTypes.default.string,
    data: _propTypes.default.arrayOf(_propTypes.default.shape({
      id: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]).isRequired,
      x: _propTypes.default.number.isRequired,
      y: _propTypes.default.number.isRequired
    })).isRequired,
    highlightScope: _propTypes.default.shape({
      faded: _propTypes.default.oneOf(['global', 'none', 'series']),
      highlighted: _propTypes.default.oneOf(['item', 'none', 'series'])
    }),
    id: _propTypes.default.string.isRequired,
    label: _propTypes.default.string,
    markerSize: _propTypes.default.number,
    type: _propTypes.default.oneOf(['scatter']).isRequired,
    valueFormatter: _propTypes.default.func.isRequired,
    xAxisKey: _propTypes.default.string,
    yAxisKey: _propTypes.default.string
  }).isRequired,
  xScale: _propTypes.default.func.isRequired,
  yScale: _propTypes.default.func.isRequired
} : void 0;